#!/sbin/sh
##########################################################################################
#
# Magisk Module Template Install Script
# by topjohnwu
#
##########################################################################################

# Detect whether in boot mode
ps | grep zygote | grep -v grep >/dev/null && BOOTMODE=true || BOOTMODE=false
$BOOTMODE || ps -A 2>/dev/null | grep zygote | grep -v grep >/dev/null && BOOTMODE=true

# This path should work in any cases
TMPDIR=/dev/tmp
INSTALLER=$TMPDIR/magisk
SYSTEM=/system

# Default permissions
umask 022

# Initial cleanup
rm -rf $TMPDIR 2>/dev/null
mkdir -p $INSTALLER

ABDeviceCheck=$(cat /proc/cmdline | grep slot_suffix | wc -l)
if [ $ABDeviceCheck -gt 0 ];
then  
  isABDevice=true  
  SLOT=$(for i in `cat /proc/cmdline`; do echo $i | grep slot_suffix | awk -F "=" '{print $2}';done)  
  SYSTEM=/system/system
else  
  isABDevice=false
fi

##########################################################################################
# Environment
##########################################################################################

OUTFD=$2
ZIP=$3

# echo before loading util_functions
ui_print() { echo "$1"; }

require_new_magisk() {
  ui_print "***********************************"
  ui_print "! $MAGISKBIN isn't setup properly!"
  ui_print "! Please install Magisk v16.3+!"
  ui_print "***********************************"
  exit 1
}

########################################################################################### 
#Functions
##########################################################################################
ui_print() {
if $BOOTMODE; then    
echo "$1"  
else     
echo -n -e "ui_print $1\n" >> /proc/self/fd/$OUTFD    
echo -n -e "ui_print\n" >> /proc/self/fd/$OUTFD  
fi
}

find_boot_image() {  
srch_str="kern-a KERN-A android_boot ANDROID_BOOT kernel KERNEL boot BOOT lnx LNX"  
if $isABDevice  
then    
srch_str="boot_$SLOT BOOT_$SLOT kern-$SLOT KERN-$SLOT"+$srch_str  
fi  
if [ -z "$BOOTIMAGE" ]; then    
for PARTITION in $srch_str; do      
BOOTIMAGE=`readlink /dev/block/by-name/$PARTITION || readlink /dev/block/platform/*/by-name/$PARTITION || readlink /dev/block/platform/*/*/by-name/$PARTITION`      
if [ ! -z "$BOOTIMAGE" ]; then 
break; 
fi    
done  
fi  
if [ -z "$BOOTIMAGE" ]; then    
FSTAB="/etc/recovery.fstab"    [ ! -f "$FSTAB" ] && FSTAB="/etc/recovery.fstab.bak"    [ -f "$FSTAB" ] && BOOTIMAGE=`grep -E '\b/boot\b' "$FSTAB" | grep -oE '/dev/[a-zA-Z0-9_./-]*'`  
fi
}
is_mounted() {  
if [ ! -z "$2" ]; then    
cat /proc/mounts | grep $1 | grep $2, >/dev/null  
else    
cat /proc/mounts | grep $1 >/dev/null  
fi  
return $?
}

mount_image() {  
if [ ! -d "$2" ]; then    
mount -o rw,remount rootfs /    mkdir -p $2 2>/dev/null    ($BOOTMODE) && mount -o ro,remount rootfs /    [ ! -d "$2" ] && return 1  
fi  
if (! is_mounted $2); then    
LOOPDEVICE=    
for LOOP in 0 1 2 3 4 5 6 7; do      
if (! is_mounted $2); then        
LOOPDEVICE=/dev/block/loop$LOOP        
if [ ! -f "$LOOPDEVICE" ]; then          
mknod $LOOPDEVICE b 7 $LOOP 2>/dev/null        
fi        
losetup $LOOPDEVICE $1        
if [ "$?" -eq "0" ]; then          
mount -t ext4 -o loop $LOOPDEVICE $2          
if (! is_mounted $2); then            
$SYSTEM/bin/toolbox mount -t ext4 -o loop $LOOPDEVICE $2          
fi          
if (! is_mounted $2); then            
$SYSTEM/bin/toybox mount -t ext4 -o loop $LOOPDEVICE $2          
fi        
fi        
if (is_mounted $2); then          
ui_print "- Mounting $1 to $2"          
break;        
fi      
fi    
done  
fi
}

grep_prop() {  
REGEX="s/^$1=//p"  shift  FILES=$@  
if [ -z "$FILES" ]; then    
FILES="$SYSTEM/build.prop"  
fi  
cat $FILES 2>/dev/null | sed -n "$REGEX" | head -n 1
}

set_perm() {  
chown $2:$3 $1 || exit 1  
chmod $4 $1 || exit 1  
if [ ! -z "$5" ]; then    
chcon $5 $1 2>/dev/null  
else    
chcon 'u:object_r:system_file:s0' $1 2>/dev/null  
fi
}

set_perm_recursive() {  
find $1 -type d 2>/dev/null | while read dir; do    
set_perm $dir $2 $3 $4 $6  
done  
find $1 -type f 2>/dev/null | while read file; do    
set_perm $file $2 $3 $5 $6  
done
}

mktouch() {  
mkdir -p ${1%/*}  
if [ -z "$2" ]; then    
touch $1  
else    
echo $2 > $1  
fi  
chmod 644 $1
}

request_size_check() {  
reqSizeM=`unzip -l "$1" 2>/dev/null | tail -n 1 | awk '{ print $1 }'`  reqSizeM=$((reqSizeM / 1048576 + 1))
}

image_size_check() {  
e2fsck -yf $1  curBlocks=`e2fsck -n $1 2>/dev/null | grep $1 | cut -d, -f3 | cut -d\  -f2`;  
curUsedM=`echo "$curBlocks" | cut -d/ -f1`  
curSizeM=`echo "$curBlocks" | cut -d/ -f1`  
curFreeM=$(((curSizeM - curUsedM) * 4 / 1024))  
curUsedM=$((curUsedM * 4 / 1024 + 1))  
curSizeM=$((curSizeM * 4 / 1024))
}

########################################################################################### 
#Flashable update-binary preparation
##########################################################################################
OUTFD=$2
ZIP=$3

readlink /proc/$$/fd/$OUTFD 2>/dev/null | grep /tmp >/dev/nullif [ "$?" -eq "0" ]; then  
OUTFD=0

  for FD in `ls /proc/$$/fd`; do    
  readlink /proc/$$/fd/$FD 2>/dev/null | grep pipe >/dev/null    
  if [ "$?" -eq "0" ]; then      
  ps | grep " 3 $FD " | grep -v grep >/dev/null      
  if [ "$?" -eq "0" ]; then        
  OUTFD=$FD        
  break      
  fi    
  fi  
  done
  fi
  
if $BOOTMODE && ! is_mounted /magisk; then  
ui_print "! Magisk is not activated!... abort"  
exit 1
fi

# Fix SuperSU.....
$BOOTMODE && $BINDIR/sepolicy-inject --live "allow fsck * * *"
# This path should work in any cases
TMPDIR=/dev/tmp
MOUNTPATH=/system/data/adb
IMGNAME=magisk.img

mkdir -p $TMPDIR 2>/dev/null
cd $TMPDIR
unzip -o "$ZIP" config.sh

if [ ! -f "config.sh" ]; then  
ui_print "! Failed: Unable to extract zip file!"  
exit 1
fi

source config.sh

INSTALLER=$TMPDIR/$MODID
MODPATH=$MOUNTPATH/magisk/$MODID

mkdir -p $INSTALLER
cd $INSTALLER
unzip -o "$ZIP" "common/*" module.prop

##########################################################################################
#Main
##########################################################################################
# Print mod nameprint_modname

# Please leave this message in your flashable zip for credits :)
ui_print "******************************"
ui_print "Powered by Magisk (@topjohnwu)"
ui_print " "ui_print "EVilTheme made by Spannaa@XDA"ui_print "Merged into Magisk by djb77"
ui_print "******************************"

ui_print "- Mounting /system(ro), /cache, /data"
mount -o ro /system 2>/dev/null
if $isABDevice
then  
mount -o rw,remount /system 2>/dev/null
fi
mount /cache 2>/dev/null
mount /data 2>/dev/null

if [ ! -f "$SYSTEM/build.prop" ]; then  
ui_print "! Failed: /system could not be mounted!"  
exit 1
fi

# read override variables
getvar KEEPVERITY
getvar KEEPFORCEENCRYPT
getvar BOOTIMAGE

[ -z $KEEPVERITY ] && KEEPVERITY=false
[ -z $KEEPFORCEENCRYPT ] && KEEPFORCEENCRYPT=false

# Check if system root is installed and removeremove_system_su

API=`grep_prop ro.build.version.sdk`
ABI=`grep_prop ro.product.cpu.abi | cut -c-3`
ABI2=`grep_prop ro.product.cpu.abi2 | cut -c-3`
ABILONG=`grep_prop ro.product.cpu.abi`

ARCH=arm
IS64BIT=false
if [ "$ABI" = "x86" ]; then ARCH=x86; fi;
if [ "$ABI2" = "x86" ]; then ARCH=x86; fi;
if [ "$ABILONG" = "arm64-v8a" ]; then ARCH=arm64; IS64BIT=true; fi;
if [ "$ABILONG" = "x86_64" ]; then ARCH=x64; IS64BIT=true; fi;
if [ "$API" -lt "21" ]; then  
ui_print "! Magisk is only for Lollipop 5.0+ (SDK 21+)"  exit 1
fi

ui_print "- Device platform: $ARCH"

BINDIR=$INSTALLER/$ARCH
chmod -R 755 $CHROMEDIR $BINDIR

SYSTEMLIB=$SYSTEM/lib
$IS64BIT && SYSTEMLIB=$SYSTEM/lib64

find_boot_image
if [ -z $BOOTIMAGE ]; then  
ui_print "! Unable to detect boot image"  exit 1
fi

# You can get the Android API version from $API, the CPU architecture from $ARCH
# Useful if you are creating Android version / platform dependent mods

if is_mounted /data; then  
IMG=/data/adb/$IMGNAME  
if [ ! -f "/data/adb/magisk.img" ]; then    
ui_print "! Magisk is not installed!"    
ui_print "! Magisk is required for this mod!"    exit 1
fi
else  
IMG=/cache/magisk.img  
ui_print " "  
ui_print "***********************************"  
ui_print "*      !! Data unavailible !!     *"  
ui_print "* Magisk detection is impossible  *"  
ui_print "* Installation will still proceed *"  
ui_print "*  But please make sure you have  *"  
ui_print "*        Magisk installed!!       *"  
ui_print "***********************************"  
ui_print " "
fi

request_size_check "$ZIP"

if [ -f "$IMG" ]; then  
ui_print "- $IMG detected!"  
image_size_check $IMG  
if [ "$reqSizeM" -gt "$curFreeM" ]; then    
SIZE=$(((reqSizeM + curUsedM) / 32 * 32 + 64))    
ui_print "- Resizing $IMG to ${SIZE}M..."    
resize2fs $IMG ${SIZE}M  
fi
else  
SIZE=$((reqSizeM / 32 * 32 + 64));  
ui_print "- Creating $IMG with size ${SIZE}M"  
make_ext4fs -l ${SIZE}M -a /magisk -S $INSTALLER/common/file_contexts_image $IMG
fi

mount_image $IMG $MOUNTPATH
if ! is_mounted $MOUNTPATH; then  
ui_print "! $IMG mount failed... abort"  exit 1
fi

# Create mod paths
rm -rf $MODPATH 2>/dev/null
mkdir -p $MODPATH

# Copy files
ui_print "- Copying files"
unzip -o "$ZIP" "system/*" -d $MODPATH

##########################################################################################
# EVilTheme Mod integrated by djb77
###########################################################################################
# Copying EVilTheme Files
ui_print "- Copying EVilTheme Files"
mkdir -p /data/tmp/eviltheme
chmod -R 777 /data/tmp/eviltheme
unzip -o "$ZIP" engine/* -d /tmp
unzip -o "$ZIP" eviltheme/* -d /data/tmp
rm -f /data/tmp/eviltheme/system/placeholder

# Execute EVilTheme
ui_print "- Executing EVilTheme"
chmod -R 775 /tmp/engine/tmp/engine/installtheme.sh

# Resize Magisk image if needed
payload_size_check "/tmp/magisk_tmp/*" "*"
if [ -f "$IMG" ]; then  
target_size_check $IMG  
if [ "$reqSizeM" -gt "$curFreeM" ]; then    
SIZE=$((((reqSizeM + curUsedM) / 32 + 2) * 32))    
ui_print "- Resizing $IMG to ${SIZE}M..."    
resize2fs $IMG ${SIZE}M  
fi
else  
SIZE=$(((reqSizeM / 32 + 2) * 32));  
ui_print "- Creating $IMG with size ${SIZE}M"  
make_ext4fs -l ${SIZE}M -a /magisk -S $INSTALLER/common/file_contexts_image $IMG
fi
mount_image $IMG $MOUNTPATH
if (! is_mounted $MOUNTPATH); then  
ui_print "! $IMG mount failed... abort"  
exit 1
fi

# Copy Patched Files to Magisk Module
ui_print "- Copying Patched Files to Magisk Module"
cp -rf /tmp/magisk_tmp/* $MODPATH
rm -rf /tmp/magisk_tmp
rm -rf /data/tmp/magisk

##########################################################################################
# Handle replace folders
for TARGET in $REPLACE; do  
mktouch $MODPATH$TARGET/.replace
done

# Auto Mount
if $AUTOMOUNT; then  
mktouch $MODPATH/auto_mount
fi

# prop files
if $PROPFILE; then  
cp -af $INSTALLER/common/system.prop $MODPATH/system.prop
fi

# Module info
cp -af $INSTALLER/module.prop $MODPATH/module.prop
if $BOOTMODE; then  
# Update info for Magisk Manager  
mktouch /magisk/$MODID/update  
cp -af $INSTALLER/module.prop /magisk/$MODID/module.prop
fi

# post-fs-data mode scripts
if $POSTFSDATA; then  
cp -af $INSTALLER/common/post-fs-data.sh $MODPATH/post-fs-data.sh
fi

# service mode scripts
if $LATESTARTSERVICE; then  
cp -af $INSTALLER/common/service.sh $MODPATH/service.sh
fi

ui_print "- Setting permissions"
set_permissions

ui_print "- Unmounting partitions"

umount $MOUNTPATH
losetup -d $LOOPDEVICE
rmdir $MOUNTPATH
# Shrink the image if possible
image_size_check $IMG
NEWDATASIZE=$((curUsedM / 32 * 32 + 32))
if [ "$curSizeM" -gt "$NEWDATASIZE" ]; then  
ui_print "- Shrinking $IMG to ${NEWDATASIZE}M..."  
resize2fs $IMG ${NEWDATASIZE}M
fi

if ! $BOOTMODE; then  
umount /system  umount /vendor 2>/dev/null
fi

ui_print "- Done"
exit 0
